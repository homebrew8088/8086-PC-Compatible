
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INT 0X13 SOFTWARE DISK INTERRUPTS
;DONT FORGET HARDWARE INTERRUPTS ARE DISABLED WHEN SOFTWARE INTERRUPTS ARE CALLED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
INT13:
	CMP DL, 0X80		;CHECK FOR DISK NUMBER BEING REQUESTED 
	JE .START_INT13		;JMP IF 0X80 C:
	JNE .NOT_A_DRIVE	;JMP IF NOT C: NOT A DRIVE IN THE SYSTEM

  .START_INT13:	
	CMP AH, 0X00
	JE .RESET_DISK_SYSTEM 			;RESET DISK
	CMP AH, 0X01
	JE .GET_STATUS_LAST_OPERATION	;GET STATUS OF LAST OPERATION 
	CMP AH, 0X02	
	JE .DISK_READ					;READ DISK CHS
	CMP AH, 0X03
	;JE .WRITE_DISK					;WRITE DISK CHS
	CMP AH, 0X08
	JE .PARAMETERS					;GET DISK PARAMETERS
	CMP AH, 0X15
	JE .GET_DISK_TYPE				;GET DISK TYPE	
									;FUNCTION NOT FOUND
	MOV AH, 0X01					;INVALID FUNCTION IN AH
	STC								;SET CARRY FLAG 	
	JMP .INT13_END_WITH_CARRY_FLAG
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;RESET DISK 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		
.RESET_DISK_SYSTEM:	
					
	MOV AH, 0X00		;STATUS 0X00 SUCCESSFULL
	CLC					;CLEAR CARRY FLAG SUCCESFUL	
	JMP .INT13_END_WITH_CARRY_FLAG

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;STATUS OF LAST OPERATION  
;THIS PROABLY WILL NEED WORK
;THE CH376 ERROR STATUS NUMBERS DO NOT MATCH PC COMPATABLE NUMBERS
;STATUS 0X14 IS SUCCESS AND INTERPRETED TO RETURN 0X00
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;		
.GET_STATUS_LAST_OPERATION:	
	
	MOV AL, 0X22		;GET_STATUS OF INT
	OUT 0XE4, AL		;OUT COMMAND PORT				
	IN AL, 0XE0			;READ IN STATUS DATA PORT
	
	CMP AL, 0X14		;CHECK FOR USB_INT_SUCCESS
	JNE .STATUS_DISK_ERROR;IF USB_INT_SUCCESS
	
	MOV AH, 0X00		;STATUS 0X00 SUCCESSFULL
	CLC					;CLEAR CARRY FLAG SUCCESFUL	
	JMP .INT13_END_WITH_CARRY_FLAG
	
.STATUS_DISK_ERROR:
	MOV AH, AL			;STATUS CODE
	STC					;SET CARRY FLAG 	
	JMP .INT13_END_WITH_CARRY_FLAG
	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;READ DISK SECTOR	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;LBA = (C × HPC + H) × SPT + (S − 1)
;MAX NUMBERS C = 0X3FF, H = 0XFF, S = 0X3F
;AH = 02h
;AL = number of sectors to read (must be nonzero)
;CH = low eight bits of cylinder number
;CL = sector number 1-63 (bits 0-5)
;high two bits of cylinder (bits 6-7, hard disk only)
;DH = head number
;DL = drive number (bit 7 set for hard disk)
;ES:BX -> data buffer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.DISK_READ:
	PUSH BX					;
	PUSH CX					;STORE REGISTERS
	PUSH DX					;
	PUSH DS					;
	PUSH ES					;
	
	
	PUSH AX					;STORE AX / AL NUMBER OF SECTORS
	PUSH AX					;STORE AX / AL NUMBER OF SECTORS
	
	PUSH CX					;STORE CX / SECTOR NUMBER
	PUSH DX					;STORE DX / DH HEAD NUMBER
	
	MOV AX, 0XF400			;DRIVE DATA AREA
	MOV DS, AX				;SET DS TO 0XF400
	
	MOV AL, CH				;GET LOWER CYLINDER NUMBER
	SHR CL, 0X01			;SHIFT RIGHT 6 TIMES FOR UPPER 2 BITS CYLINDER
	SHR CL, 0X01			;
	SHR CL, 0X01			;
	SHR CL, 0X01			;	
	SHR CL, 0X01			;
	SHR CL, 0X01			;
	MOV AH, CL				;AX HOLDS CYLINDER NUMBER			;
	MOV CX, [0X021A]		;NUMBER OF HEADS / SIDES (HPC)
	MUL CX					;AX = C X HPC
	POP CX					;GET HEAD NUMBER
	MOV CL, CH				;MOV HEAD NUMBER
	MOV CH, 0X00			;CLEAR CH
	ADD AX, CX				;ADD IN HEAD (C X HPC + H)
	MOV CX, [0X0218]		;SECTORS PER TRACK	
	MUL CX					;DX:AX (C X HPC + H) X SPT
	POP CX					;GET SECTOR NUMBER
	AND CX, 0X003F			;CLEAR OUT CYLINDER
	DEC CX					;(S - 1)
	ADD AX, CX				;LBA = (C × HPC + H) × SPT + (S − 1)
	ADC DX, 0X00			;IF THERE IS A CARRY POSIBLE I DONT KNOW
							;DX:AX = LBA
	PUSH DX					;STORE LBA UPPER
	PUSH AX					;STORE LBA LOWER
		
	
	MOV AL, 0X54	;DISK_READ
	OUT 0XE4, AL	;OUT COMMAND PORT
	POP AX			;GET LOWER LBA
	OUT 0XE0, AL	;OUT DATA PORT
	MOV AL, AH		;NEXT BYTE
	OUT 0XE0, AL	;OUT DATA PORT
	POP AX			;GET UPPER LBA
	OUT 0XE0, AL	;OUT DATA PORT
	MOV AL, AH		;NEXT BYTE
	OUT 0XE0, AL	;OUT DATA PORT
	POP AX			;GET NUMBER OF SECTORS
	OUT 0XE0, AL	;OUT DATA PORT

.READ_SECTOR:
	MOV CX, 0X00FF		;DELAY 
	DB 0XE2, 0XFE		;LOOP BACK
	
	MOV AL, 0X22		;GET_STATUS
	OUT 0XE4, AL		;OUT COMMAND PORT
	IN AL, 0XE0			;READ IN STATUS DATA PORT
	CMP AL, 0X14		;CHECK FOR USB_INT_SUCCESS COMPLETED READING
	JE .READ_DISK_SUCCESS;IF USB_INT_SUCCESS
	CMP AL, 0X1D		;COMPARE TO USB_INT_DISK_READ
	JNE .NOT_1D			;IF NOT USB_INT_DISK_READ
	
	MOV AL, 0X27		;RD_USB_DATA0
	OUT 0XE4, AL		;OUT COMMAND PORT
	IN AL, 0XE0			;READ NUMBER OF BYTES FROM DATA PORT 
	MOV AH, 0X00		;CLEAR AH
	MOV CX, AX			;SET CX TO NUMBER OF BYTES
  .READ_IN_LOOP:		;LOOP LABLE
	IN AL, 0XE0			;READ BYTE
	MOV [ES:BX], AL		;STORE BYTE
	INC BX				;INC BX
	LOOP .READ_IN_LOOP	;LOOP UNTIL DONE
	
	MOV AL, 0X55		;DISK_RD_GO READ NEXT 64 BYTES
	OUT 0XE4, AL		;OUT COMMAND PORT
	JMP .READ_SECTOR	;LOOP UNTIL DONE

		
.NOT_1D:
	CALL WIRTE_AL_INT10_E			;PRINTS ERROR NUMBER TO SCREEN
	MOV AX, CS						;GET CS 
	MOV DS, AX						;SET DS TO CS
	MOV AH, 0X0E					;FOR TELOTYPE
	MOV CX, .END_READ_ERROR_MESSAGE - .READ_ERROR_MESSAGE
	MOV BX, .READ_ERROR_MESSAGE	
	.LOOP_NOT_1D:
	MOV AL, [BX]					;GET BYTE 
	INT 0X10						;PRINT TO SCREEN
	INC BX							;INC BX
	LOOP .LOOP_NOT_1D				;LOOP UNTIL DONE
	JMP .READ_DISK_ERROR

	.READ_ERROR_MESSAGE:
	DB 0X0D, 0X0A, 'USB READ ERR0R', 0X0D, 0X0A
	.END_READ_ERROR_MESSAGE:

.READ_DISK_SUCCESS:
	POP AX
	POP ES
	POP DS
	POP DX
	POP CX
	POP BX
	MOV AH, 0X00		;STATUS 0X00 SUCCESSFULL
	CLC					;CLEAR CARRY FLAG SUCCESFUL	
	JMP .INT13_END_WITH_CARRY_FLAG
	
.READ_DISK_ERROR:
	POP ES
	POP ES
	POP DS
	POP DX
	POP CX
	POP BX

	MOV AH, AL			;STATUS CODE
	STC					;SET CARRY FLAG 
	JMP .INT13_END_WITH_CARRY_FLAG


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;GET PARAMETERS	0X08
;RETURNS
;AH=STATUS 0X00 IS GOOD
;BL=DOES NOT APPLY 
;CH=CYLINDERS
;CL=0-5 SECTORS PER TRACK 6-7 UPPER 2 BITS CYLINDER
;DH=NUMBER OF HEADS / SIDES -1
;DL=NUMBER OF DRIVES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
.PARAMETERS:
	PUSH AX					;STORE AX
	PUSH BX					;STORE BX
	PUSH DS					;STORE DS
	
	MOV AX, 0XF400			;DRIVE DATA AREA
	MOV DS, AX				;SET DS TO 0XF400
	
	MOV BX, 0X03FE			;INDEX OF VOLUME BOOT SIGNATURE 
	CMP WORD [BX], 0XAA55	;TEST TO SEE IF PRESENT
	JNE .PARAMETERS_NOT_P 	;IF NOT THERE
	
	MOV BX, 0X0213			;INDEX 0XF400:0X0213 SMALL SECTOR COUNT
	CMP WORD [BX], 0X0000	;IF ZERO THEN IT IS A LARGER THAN 32MB
	JE .LARGE_SECTOR_COUNT_PARAMETERS	;JMP TO LARGE DRIVE CODE
	
.SMALL_SECTOR_COUNT_PARAMETERS:	
	MOV DX, 0X0000			;DX = 0
	MOV AX, [0X213]			;GET SECTOR COUNT
	JMP .CONTINUE_PARAMETERS
.LARGE_SECTOR_COUNT_PARAMETERS:	
	MOV DX, [0X0222]		;DX UPPER 2 BYTES SECTOR COUNT
	MOV AX, [0X0220]		;AX LOWER 2 BYTES SECTOR COUNT	
		JMP .CONTINUE_PARAMETERS
.CONTINUE_PARAMETERS:
	MOV CX, [0X0218]		;SECTORS PER TRACK
	DIV CX					;DIV DX:AX / CX
	MOV DX, 0X0000			;CLEAR DX JUST IN CASE THERE SHOULD NOT BE A REMANDER 
	MOV CX, [0X021A]		;NUMBER OF HEADS / SIDES
	DIV CX					;DIV DX:AX / CX
							;NOW WE HAVE CYLINDERS 
	MOV CH, AL				;CH=0-7 CYLINDERS
	SHL AH, 0X01			;SHIFT LEFT 6 TIMES UPPER 2 BITS CYLINDER
	SHL AH, 0X01			;
	SHL AH, 0X01			;
	SHL AH, 0X01			;
	SHL AH, 0X01			;
	SHL AH, 0X01			;
	MOV CL, [0X0218]		;SECTORS PER TRACK
	AND CL, 0X3F			;CLEAR BITS 7-6
	ADD CL, AH				;ADD IN 8-9 BITS CYLINDER
	MOV DH,  [0X021A]		;NUMBER OF HEADS / SIDES
	DEC DH					;START 0 NOT 1
	MOV DL, 0X01			;NUMBER OF DRIVES
	JMP .END_PARAMETERS

.END_PARAMETERS:
	POP DS				;RESTORE DS
	POP BX				;RESTORE BX
	POP AX				;RESTORE AX
	
	MOV AH, 0X00		;STATUS 0X00 SUCCESSFULL
	CLC					;CLEAR CARRY FLAG SUCCESFUL	
	JMP .INT13_END_WITH_CARRY_FLAG
	
.PARAMETERS_NOT_P:
	POP DS				;RESTORE DS
	POP BX				;RESTORE BX
	POP AX				;RESTORE AX
	
	MOV AH, 0X01		;STATUS 0X00 SUCCESSFULL
	STC 				;SET CARRY FLAG	
	JMP .INT13_END_WITH_CARRY_FLAG

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;GET DISK TYPE	0X15
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.GET_DISK_TYPE:
	PUSH BX					;STORE BX
	PUSH DS					;STORE DS
	MOV AX, 0XF400			;DRIVE DATA AREA
	MOV DS, AX				;SET DS TO 0XF400
	
	MOV BX, 0X03FE			;INDEX OF VOLUME BOOT SIGNATURE 
	CMP WORD [BX], 0XAA55	;TEST TO SEE IF PRESENT
	JNE .GET_DISK_TYPE_NOT_P ;IF NOT THERE
	
	MOV BX, 0X0213			;INDEX 0XF400:0X0213 SMALL SECTOR COUNT
	CMP WORD [BX], 0X0000	;IF ZERO THEN IT IS A LARGER THAN 32MB
	JE .LARGE_SECTOR_COUNT	;JMP TO LARGE DRIVE CODE
	
.SMALL_SECTOR_COUNT:
	MOV DX, [BX]			;CX:DX NUMBER OF SECTORS
	MOV CX, 0X0000			;SMALL SECTOR CX IS 0X0000
	MOV AX, 0X0300			;AH=0X03 FIXED DISK AL=RETURN 0X00
	JMP .END_GET_DISK_TYPE	;END
	
.LARGE_SECTOR_COUNT:
	MOV BX, 0X0220			;INDEX 0XF400:0X0200 LARGE SECTOR COUNT
	MOV DX, [BX]			;CX:DX NUMBER OF SECTORS
	ADD BX, 0X02			;INC BX 2
	MOV CX, [BX]			;CX:DX NUMBER OF SECTORS
	MOV AX, 0X0300			;AH=0X03 FIXED DISK AL=RETURN 0X00
	JMP .END_GET_DISK_TYPE	;END
	
.GET_DISK_TYPE_NOT_P:
	MOV AX, 0X0000			;AH=0X00 WHEN NOT PRESENT 
	JMP .END_GET_DISK_TYPE
	
.END_GET_DISK_TYPE:
	POP DS					;RESTORE DS
	POP BX					;RESTORE BX
	CLC						;CLEAR CARRY FLAG SUCCESFUL	
	JMP .INT13_END_WITH_CARRY_FLAG


	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;END INT 0X13 WITH UPDATED CARRY FLAG		
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  .INT13_END_WITH_CARRY_FLAG:	;THIS IS HOW I RETURN THE CARRY FLAG
	PUSH AX						;STORE AX
	PUSHF						;STORE FLAGS
	POP AX						;GET AX = FLAGS
	PUSH BP						;STORE BP
	MOV BP, SP              	;Copy SP to BP for use as index
	ADD BP, 0X08				;offset 8
	AND WORD [BP], 0XFFFE		;CLEAR CF = ZER0
	AND AX, 0X0001				;ONLY CF 
	OR	WORD [BP], AX			;SET CF AX
	POP BP               		;RESTORE BASE POINTER
	POP AX						;RESTORE AX	
	IRET						;RETRUN

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;WHEN REQUEST IS NOT A VALID DRIVE NUMBER
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  .NOT_A_DRIVE:
	MOV AH, 0X01	;STATUS 0X00 SUCCESSFULL
	STC				;SET CARRY FLAG
	JMP .INT13_END_WITH_CARRY_FLAG

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;THIS LOADS THE MBR TO 0XF400:0000
;LOADS THE VBR TO 0XF400:0200
;USED BY INT 0X13 FOR CHS->LBA CALC	
;THE VBR HAS THE DRIVE GEOMETRY AT 
;0XF400:0X0218 DW SPT
;0XF400:0X021A DW HPC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LOAD_BOOT_RECORD:
	
	PUSHF			;STORE FLAGS
	CLI				;
	PUSH AX			;STORE AX
	PUSH BX			;STORE BX
	PUSH CX			;STORE CX
	PUSH DS			;STORE DS
	MOV AX, 0XF400	;
	MOV DS, AX		;SET DS 0XF400 UPPER RAM
	MOV BX, 0X0000	;SET BX 0 FOR INDEX
					;READ MBR
	MOV AL, 0X54	;DISK_READ COMMAND
	OUT 0XE4, AL	;OUT COMMAND PORT
	MOV AL, 0X00	;LBA 0X00000000
	OUT 0XE0, AL	;OUT COMMAND PORT
	OUT 0XE0, AL	;OUT COMMAND PORT
	OUT 0XE0, AL	;OUT COMMAND PORT
	OUT 0XE0, AL	;OUT COMMAND PORT
	MOV AL, 0X01	;READ ONE SECTOR
	OUT 0XE0, AL	;OUT COMMAND PORT

.READ_MBR_SECTOR:
	MOV CX, 0X00FF		;DELAY 
	DB 0XE2, 0XFE		;LOOP BACK
	
	MOV AL, 0X22		;GET_STATUS
	OUT 0XE4, AL		;OUT COMMAND PORT
	IN AL, 0XE0			;READ IN STATUS DATA PORT
	CMP AL, 0X14		;CHECK FOR USB_INT_SUCCESS COMPLETED READING
	JE .READ_MBR_SUCCESS;IF USB_INT_SUCCESS
	CMP AL, 0X1D		;COMPARE TO USB_INT_DISK_READ
	JNE .NOT_1D			;IF NOT USB_INT_DISK_READ
	
	MOV AL, 0X27		;RD_USB_DATA0
	OUT 0XE4, AL		;OUT COMMAND PORT
	IN AL, 0XE0			;READ NUMBER OF BYTES FROM DATA PORT 
	MOV AH, 0X00		;CLEAR AH
	MOV CX, AX			;SET CX TO NUMBER OF BYTES
  .READ_MBR_LOOP:		;LOOP LABLE
	IN AL, 0XE0			;READ BYTE
	MOV [BX], AL		;WRITE BYTE TO DS:BX
	INC BX				;INC INDEX
	LOOP .READ_MBR_LOOP	;LOOP UNTIL DONE
	
	MOV AL, 0X55		;DISK_RD_GO READ NEXT 64 BYTES
	OUT 0XE4, AL		;OUT COMMAND PORT
	JMP .READ_MBR_SECTOR;LOOP UNTIL DONE

.NOT_1D:
	CALL WIRTE_AL_INT10_E			;PRINTS ERROR NUMBER TO SCREEN	
	MOV AX, CS						;GET CS 
	MOV DS, AX						;SET DS TO CS
	MOV AH, 0X0E					;FOR TELOTYPE
	MOV CX, .END_READ_ERROR_MESSAGE - .READ_ERROR_MESSAGE
	MOV BX, .READ_ERROR_MESSAGE	
	.LOOP_NOT_1D:
	MOV AL, [BX]					;GET BYTE 
	INT 0X10						;PRINT TO SCREEN
	INC BX							;INC BX
	LOOP .LOOP_NOT_1D				;LOOP UNTIL DONE
	
	JMP .END_LOAD_BOOT_RECORD

	.READ_ERROR_MESSAGE:
	DB ' USB READ ERR0R', 0X0D, 0X0A
	.END_READ_ERROR_MESSAGE:
	
.NOT_BOOTABLE_MBR:
	MOV AX, CS						;GET CS 
	MOV DS, AX						;SET DS TO CS
	MOV AH, 0X0E					;FOR TELOTYPE
	MOV CX, .END_NOT_MBR_MESSAGE - .NOT_MBR_MESSAGE
	MOV BX, .NOT_MBR_MESSAGE
    .LOOP_NOT_MBR:	
	MOV AL, [BX]					;GET BYTE 
	INT 0X10						;PRINT TO SCREEN
	INC BX							;INC BX
	LOOP .LOOP_NOT_MBR				;LOOP UNTIL DONE
	
	JMP .END_LOAD_BOOT_RECORD

	.NOT_MBR_MESSAGE:
	DB 'NO BOOT SIGNATURE MBR', 0X0D, 0X0A
	.END_NOT_MBR_MESSAGE:
	
.READ_MBR_SUCCESS:
	MOV BX, 0X01FE			;END OF MBR DS STILL IS 0XF400
	CMP WORD [BX], 0XAA55	;BOOT SIGNATURE DS:BX
	JNE .NOT_BOOTABLE_MBR	;IF BOOT SIGNATURE IS NOT THERE
	
	CALL WAIT_8			;DELAY NEEDED BEFORE READING THE NEXT SECTOR 
			
	
	MOV BX, 0X01BE			;FIRST PARTITION ENTRY 
	CMP BYTE [BX], 0X80		;CHECK FOR BOOTABLE
	JE .BOOT_FIRST_ENTRY	;
	MOV BX, 0X01CE			;SECOND PARTITION ENTRY 
	CMP BYTE [BX], 0X80		;CHECK FOR BOOTABLE
	JE .BOOT_SECOND_ENTRY	;
	MOV BX, 0X01DE			;THRID PARTITION ENTRY 
	CMP BYTE [BX], 0X80		;CHECK FOR BOOTABLE
	JE .BOOT_THIRD_ENTRY	;
	MOV BX, 0X01EE			;FORTH PARTITION ENTRY 
	CMP BYTE [BX], 0X80		;CHECK FOR BOOTABLE
	JE .BOOT_FORTH_ENTRY	;
	JMP .NO_BOOTABLE_PARTITION
	
.BOOT_FIRST_ENTRY:	
	MOV AL, 0X54	;DISK_READ COMMAND
	OUT 0XE4, AL	;OUT COMMAND PORT
	MOV BX, 0X01C6	;PARTITION LBA START LOCATION
	MOV AL, [BX]	;GET BYTE
	OUT 0XE0, AL	;OUT DATA PORT
	INC BX			;NEXT BYTE
	MOV AL, [BX]	;GET BYTE
	OUT 0XE0, AL	;OUT DATA PORT
	INC BX			;NEXT BYTE
	MOV AL, [BX]	;GET BYTE
	OUT 0XE0, AL	;OUT DATA PORT
	INC BX			;NEXT BYTE
	MOV AL, [BX]	;GET BYTE
	OUT 0XE0, AL	;OUT DATA PORT
	INC BX			;NEXT BYTE
	MOV AL, 0X01	;READ ONE SECTOR
	OUT 0XE0, AL
	MOV BX, 0X0200	;SET BX 200 FOR INDEX
	JMP .READ_VBR_SECTOR
.BOOT_SECOND_ENTRY:
	MOV AL, 0X54	;DISK_READ COMMAND
	OUT 0XE4, AL	;OUT COMMAND PORT
	MOV BX, 0X01D6	;PARTITION LBA START LOCATION
	MOV AL, [BX]	;GET BYTE
	OUT 0XE0, AL	;OUT DATA PORT
	INC BX			;NEXT BYTE
	MOV AL, [BX]	;GET BYTE
	OUT 0XE0, AL	;OUT DATA PORT
	INC BX			;NEXT BYTE
	MOV AL, [BX]	;GET BYTE
	OUT 0XE0, AL	;OUT DATA PORT
	INC BX			;NEXT BYTE
	MOV AL, [BX]	;GET BYTE
	OUT 0XE0, AL	;OUT DATA PORT
	INC BX			;NEXT BYTE
	MOV AL, 0X01	;READ ONE SECTOR
	OUT 0XE0, AL
	MOV BX, 0X0200	;SET BX 200 FOR INDEX
	JMP .READ_VBR_SECTOR
.BOOT_THIRD_ENTRY:
	MOV AL, 0X54	;DISK_READ COMMAND
	OUT 0XE4, AL	;OUT COMMAND PORT
	MOV BX, 0X01E6	;PARTITION LBA START LOCATION
	MOV AL, [BX]	;GET BYTE
	OUT 0XE0, AL	;OUT DATA PORT
	INC BX			;NEXT BYTE
	MOV AL, [BX]	;GET BYTE
	OUT 0XE0, AL	;OUT DATA PORT
	INC BX			;NEXT BYTE
	MOV AL, [BX]	;GET BYTE
	OUT 0XE0, AL	;OUT DATA PORT
	INC BX			;NEXT BYTE
	MOV AL, [BX]	;GET BYTE
	OUT 0XE0, AL	;OUT DATA PORT
	INC BX			;NEXT BYTE
	MOV AL, 0X01	;READ ONE SECTOR
	OUT 0XE0, AL
	MOV BX, 0X0200	;SET BX 200 FOR INDEX
	JMP .READ_VBR_SECTOR
.BOOT_FORTH_ENTRY:
	MOV AL, 0X54	;DISK_READ COMMAND
	OUT 0XE4, AL	;OUT COMMAND PORT
	MOV BX, 0X01F6	;PARTITION LBA START LOCATION
	MOV AL, [BX]	;GET BYTE
	OUT 0XE0, AL	;OUT DATA PORT
	INC BX			;NEXT BYTE
	MOV AL, [BX]	;GET BYTE
	OUT 0XE0, AL	;OUT DATA PORT
	INC BX			;NEXT BYTE
	MOV AL, [BX]	;GET BYTE
	OUT 0XE0, AL	;OUT DATA PORT
	INC BX			;NEXT BYTE
	MOV AL, [BX]	;GET BYTE
	OUT 0XE0, AL	;OUT DATA PORT
	INC BX			;NEXT BYTE
	MOV AL, 0X01	;READ ONE SECTOR
	OUT 0XE0, AL
	MOV BX, 0X0200	;SET BX 200 FOR INDEX
	JMP .READ_VBR_SECTOR
	
.READ_VBR_SECTOR:
	MOV CX, 0X00FF		;DELAY 
	DB 0XE2, 0XFE		;LOOP BACK
	
	MOV AL, 0X22		;GET_STATUS
	OUT 0XE4, AL		;OUT COMMAND PORT
	IN AL, 0XE0			;READ IN STATUS DATA PORT
	CMP AL, 0X14		;CHECK FOR USB_INT_SUCCESS COMPLETED READING
	JE .READ_VBR_SUCCESS;IF USB_INT_SUCCESS
	CMP AL, 0X1D		;COMPARE TO USB_INT_DISK_READ
	JNE .NOT_1D			;IF NOT USB_INT_DISK_READ
	
	MOV AL, 0X27		;RD_USB_DATA0
	OUT 0XE4, AL		;OUT COMMAND PORT
	IN AL, 0XE0			;READ NUMBER OF BYTES FROM DATA PORT 
	MOV AH, 0X00		;CLEAR AH
	MOV CX, AX			;SET CX TO NUMBER OF BYTES
  .READ_VBR_LOOP:		;LOOP LABLE
	IN AL, 0XE0			;READ BYTE
	MOV [BX], AL		;WRITE BYTE TO DS:BX
	INC BX				;INC INDEX

	LOOP .READ_VBR_LOOP	;LOOP UNTIL DONE
	
	MOV AL, 0X55		;DISK_RD_GO READ NEXT 64 BYTES
	OUT 0XE4, AL		;OUT COMMAND PORT
	JMP .READ_VBR_SECTOR	;LOOP UNTIL DONE

.READ_VBR_SUCCESS:
	MOV BX, 0X01FE			;END OF MBR
	CMP WORD [BX], 0XAA55	;BOOT SIGNATURE
	JNE .NOT_BOOTABLE_VBR 	;IF BOOT SIGNATURE IS NOT THERE
	
	JMP .END_LOAD_BOOT_RECORD	
	
.NOT_BOOTABLE_VBR:
	MOV AX, CS						;GET CS 
	MOV DS, AX						;SET DS TO CS
	MOV AH, 0X0E					;FOR TELOTYPE
	MOV CX, .END_NOT_VBR_MESSAGE - .NOT_VBR_MESSAGE
	MOV BX, .NOT_VBR_MESSAGE	
	.LOOP_NOT_VBR:
	MOV AL, [BX]					;GET BYTE 
	INT 0X10						;PRINT TO SCREEN
	INC BX							;INC BX
	LOOP .LOOP_NOT_VBR				;LOOP UNTIL DONE
	
	JMP .END_LOAD_BOOT_RECORD

	.NOT_VBR_MESSAGE:
	DB 'NO BOOT SIGNATURE VBR', 0X0D, 0X0A
	.END_NOT_VBR_MESSAGE:

.NO_BOOTABLE_PARTITION:
	MOV AX, CS						;GET CS 
	MOV DS, AX						;SET DS TO CS
	MOV AH, 0X0E					;FOR TELOTYPE
	MOV CX, .END_NO_BOOTABLE_PARTITION_MESSAGE - .NO_BOOTABLE_PARTITION_MESSAGE
	MOV BX, .NO_BOOTABLE_PARTITION_MESSAGE	
	.LOOP_NO_BOOT_PARTITION:
	MOV AL, [BX]					;GET BYTE 
	INT 0X10						;PRINT TO SCREEN
	INC BX							;INC BX
	LOOP .LOOP_NO_BOOT_PARTITION	;LOOP UNTIL DONE
	
	JMP .END_LOAD_BOOT_RECORD

	.NO_BOOTABLE_PARTITION_MESSAGE:
	DB 'NO BOOT PARTITION FOUND', 0X0D, 0X0A
	.END_NO_BOOTABLE_PARTITION_MESSAGE:

.END_LOAD_BOOT_RECORD:
	POP DS	;RESTORE DS
	POP CX	;RESTORE CX
	POP BX 	;RESTORE BX
	POP AX	;RESTORE AX
	POPF	;RESTORE FLAGS
	RET		;RETURN NOT A INT
